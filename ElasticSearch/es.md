### ElasticSearch

#### lucene

- 纯java编写的全文检索工具包
- 它是一个开源的全文检索工具包，是一个全文检索框架，并不是一个全文检索引擎
- 它非常复杂，需要java集成

ElasticSearch是基于lucene的开源项目
ElasticSearch通过简单易用的Restful api接口，隐藏了lucene的复杂性

Elastic自带分布式管理，solr需要借助zookeeper实现分布式管理

#### Lucene的底层结构

分为索引和文档两部分

index索引------->document文档1(Field域 Field域)
index索引------->document文档2(Field域 Field域)

索引保存：包含的词，以及词在文档哪些位置出现
文档：可以简单理解为数据库表里面的一条数据，在内部会为它分配一个唯一的ID
文档中又分为一个个字段域，域又域名（域名可以看作是字段名，域值和类型）是key-value结构

举一个例子：

下面有三条信息：

- I like you
- I love you
- I love you too

保存成文档会变成这样:
|id:1|Content:I like you|6
|id:2|Content:I Love you|7
|id:3|Content:I Love you too|8

最后的6，7，8是lucene给的编号，和自己指定的可能不同
对文档进行分词，比如按空格分词
I     6,7,8
like  6
love  7,8
you   6,7,8
too   8
每个词在文档中出现的位置

当要搜索内容，比如搜索love，会先得到文档的编号，根据编号再来获取内容

**segement**

一个index就是一个独立的文件夹，是一个索引库
索引的内容由段组成，一个索引的内容可以包含多个段，段与段之间是独立的
lucene在写数据的时候会先写到内存中，当内存中达到一定数量的时候，会写到segment中
每个segment有独立的索引，可以独立的查询
index需要对多个segment进行查询时，会对结果进行合并

#### lucene的物理结构

_0.cfe,_0.cfs,_0.si
具有相同的名称和不同扩展名是同一个段

.si保存的是索引段的元数据信息，segment_N保存了一个提交点的信息(此索引包含多少个字段，每个字段包含多少篇文章等等)，write.lock(防止多个index writer写到一个文件中的)

.fnm正向索引相关的，保存的此段包含的所有文档，每篇文档包含了多少域，每个域包含了多少信息
.tis 反向索引相关的 .frq保存的倒排词表(包含了每个词的文档id列表),`.prx`:保存倒排词在包含此词的文档中的位置

**顺序扫描法**

将查询关键字与存储内容直接匹配，从第一个文档开始直到最后一个文档，对每个文档从开始到结尾进行扫描，假如包含关键字就是要找的文档，依次找到最后一个文档

优点：语法简单，数据量小时查询准确率高
缺点：查询时间会随之数据增长越来越大

典型的场景：mysql的like模糊查询，前一个%后一个%，这种查询不走索引，数据量小的时候还好，数据量大就很慢

#### FST

fst，有限状态机，简称状态机，是表示有限各状态以及在这些状态之间转移和动作等行为的数学模型

有限状态机，是一个非常有用的模型，可以模拟出世界上的大部分事物，它是一个数学模型，是一个抽象机器，在任何时候都可以处于有限数量的状态之一

有限状态机解决了前缀树后边不能共享的问题