## 数据结构

### 1、如何衡量程序运行的效率

编写代码的核心就是完成计算

**复杂度是什么？**

代码执行过程中会消耗计算时间和计算空间
需要衡量的就是时间复杂度和空间复杂度

**这段代码对于资源的消耗是多少**

不管是时间还是空间，它们的消耗程度都与输入的数据量高度相关
为了更客观地衡量消耗程度，通常会关注时间和空间消耗量与输入数据量之间的关系

**如何计算复杂度**

复杂度是一个关于输入数据量N的函数
假设你的代码的复杂度是f(n)--->O(f(n))

- O(n)表示复杂度与计算实例的个数n线性相关
- O(logN)表示复杂度与计算实例的个数N对数相关

复杂度的计算方法遵循以下几个原则

- 复杂度与具体的常数系数无关
例如O(n)和O(2n)表示的是同样的复杂度
o(2n)=O(n+n)=O(n)+O(n)
一段o(2n)复杂度的代码只是先后执行两遍o(n)，其复杂度是一致的

- 多项式级的复杂度项加的时候，选择高者作为结果
例如O(n^2)+O(n)和o(n^2)表示的是同样的复杂度
o(n^2)+O(n)=O(n^2+n)

只需要通过更大变化率的二阶多项式来表征复杂度就可以

- O(1)表示一个特殊的复杂度

含义为某个任务通过有限可数资源即可完成
此处有限可数的具体意义是，与输入数量n无关
例如，代码处理10条数据需要消耗5个单位的时间资源，3个单位的空间资源
处理1000条数据，消耗的资源还是这么多

一些经验：
- 一个顺序结构的代码，时间复杂度是O(1)
- 二分查找，或者更通用地说是采用分而治之的二分策略，时间复杂度都是O(logn)
- 一个简单的for循环，时间复杂度是O(n)
- 两个顺序执行的for循环，时间复杂度是O(n)+O(n)=O(2n),也就是O(n)
- 两个嵌套的for循环，时间复杂度是O(n^2)

### 将时间复杂度和空间复杂度优化

程序优化的核心思路：
- 第一步，暴力解法
在没有任何时间，空间约束下，完成代码任务的开发

- 第二步，无效操作处理
将代码中无效计算，无效存储剔除，降低时间或空间复杂度
(学会并掌握递归、二分法、排序算法、动态规划等常用的算法思维)

- 第三步，时空转换
设计合理数据结构，完成时间复杂度向空间复杂度的转移
(对数据的操作进行细分，全面掌握常见的数据结构的基础知识)


### 数据处理的基本操作

想要先弄清楚数据在代码中被处理、加工的最小单位动作


### 数组和链表

数组，是一段地址连续的内存空间，他的坏处在于，由于地址连续，每一次新增内容，如果当前数组的连续的地址没有多余的了，数组需要重新找一段地址连续的空间

另外，数组在删除数据后，需要将剩余的数据进行迁移以保证地址的连续

链表的地址不是连续的，当某个地址存储一个元素之后，它会指向下一个位置
链表有效解决了数组的麻烦，但是带了一个新的问题，链表的查找比较麻烦

时间复杂度：
操作            链表            数组

查找            O(n)           O(1)
在头部插入/删除  o(1)           O(n)
在尾部插入/删除  O(n)           O(n)
在中间插入/删除  O(n)           O(n)

链表的插入，只需要将指针指向下一个节点，但是数组需要将其余的数据都移动一下，挪个位置出来才能插入
在尾部插入，链表需要找到尾部的位置，而数组直接在尾部放就可以了
在中间插入/删除，链表和数组的时间复杂度都是O(n)，但是链表的时间用在遍历上，但是数组的时间用在挪动位置上

链表的插入/删除时间复杂度

- 当我们要插入/删除指针当前指向的节点时，时间复杂度是O(1)
- 当我们要插入/删除某个给定值的节点的时候，我们需要遍历链表，所以是O(n)。

- 链表插入/删除时间复杂度O(n)是因为需要进行遍历引起的
- 数组插入/删除时间复杂度是O(n)则是因为数据的拷贝是覆盖导致的

遍历数组和遍历链表的效率区别

在访问数组的时候，因为局部性原理，数组会把之后的连续内存都读取过来，所以之后访问的数据都在一级缓存中了，而链表的查询不会进入缓存，查询的效率就慢一些

一般来说，插入删除很少，查询非常多，又不会out of memory，采用数组，如果怕是频繁的插入，遍历，查询检索很少，就可以采用链表


### 顺序表

线性表：顺序表，链表，栈，队列

顺序表：数组、引用数组，动态数组

在程序中，我们经常要将一组元素作为一个整体来管理使用
对于这种需求，最简单的办法就是将它们看成一个序列，一旦一个数据被添加，它相对于前后元素就一直保持不变，对于这种结构，就被称之为线性表

线性表有两端，可以被称为左右，或者顶部底部，
于线性表对应的就是非线性表，比如树，图

顺序表：在计算机内存当中，用一组地址连续的存储单元，依次存储数据的线性数据结构，这里要求地址连续

数组：在连续的地址空间中，存储类型相同的数据
数组的元素位置，称之为索引
利用元素的索引可以计算出该元素对应的存储地址
索引从0开始，索引看作是起始位置的偏移量
索引为0，意味着相对于数组的第一个位置偏移量为零的位置

索引从零开始，处理器可以直接进行指针偏移计算，效率很高
例如数组索引为0，那么指针就是p+0，

数组支持随机访问

引用数组：数组中存储的是引用，就是具体的数据的地址
可以解决数据类型必须一致的问题

动态数组：由于数组的地址空间是连续的，在使用的时候，我们需要先指定他的大小
那么有没有可以动态扩容的数组呢？答案是有的
list(Python) ArrayList(java)

分配数组的时候，会预留一部分空间，扩容的时候是1.25倍扩容

数组访问越界：在go语言越界会报panic

### 链表

链表中最简单的：单项链表

它包含两个值，当前节点的元素以及指向下一个节点的指针，而最后一个指向空值

链表的第一个节点，头节点，最后一个节点，尾节点

从头节点开始，通过每个节点的引用可以移动到下一个节点，当next为空的时候，我们确定该节点为尾节点

链表的实例：至少包含一个指向头节点的引用，如果没有头部的引用的话，就没有办法定位到任何的节点

我们还可以显示的保存一个指向尾节点的引用，这样可以避免为访问尾节点而遍历整个链表

还可以保存整个链表的长度，这样可以避免为计算链表的数量而遍历整个链表

**链表的插入**

向链表头部创建节点的时候，我们首先创建一个新的节点，让这个节点上的指针指向我们当前链表的头节点，然后让链表的头指针指向新的这个节点，这样就完成了一次链表的头部插入工作

尾部同理，将它的next指针设置为空，并设置当前尾节点的指针指向这个新的节点
并将链表的尾指针指向这个节点

**链表的删除**

从链表的头部删除节点：将链表当前头节点的指针置为空，并将链表的头指针指向它的下一个节点位置

从尾部删除节点的时候，需要遍历整个链表
因为任意一个节点只有指向上一个节点的指针，没有指向下一个节点的指针

为了克服这个问题，出现了双向链表
每一个链表既有前驱，又有后继，这样我们可以从任意节点访问到它的前一个节点和后一个节点

在双链表的两端，追加了一个头节点，一个尾节点，这两个节点被称为哨兵节点
这两个节点不存储任何的元素

哨兵的优点，哨兵只需要占用很小的空间就可以改变链表的处理逻辑

这里，有了哨兵之后，链表的头节点和尾节点从来不改变

双链表的循环链表：
首节点和尾节点连接在一起就是循环链表
单链表和双链表都可以实现循环链表

它的开始和结束没有任何特点的概念，我们使用current来表示一个特点的节点
通过设置current=current.next可以有效遍历链表中的各个节点

链表的常见面试题：

1、单链表的创建和遍历
2、查找单链表中的倒数第K个节点
3、单链表的反转 **
4、合并两个有序的单链表，合并之后的链表依然有序 **
5、判断两个单链表相交的第一个交点 **
6、查找单链表的中间节点
7、从头到尾打印单链表
8、判断单链表是否有环 **
9、取出有环链表中，环的长度
10、单链表中，取出环的起始点


**栈与队列**

栈：先进后出(LIFO)
队列：先进先出(FIFO)

栈和队列就是使用最多的缓存序列

栈：可以想象想象成一摞盘子，先放下去的盘中总是在后面取出
队列：先进先出的序列

双端队列：支持在队列的头部和尾部都进行插入和删除操作的线性表
双端队列的变种：
输出受限的双端队列：
一端允许插入和删除，另一端只允许插入

输入受限的双端队列：
一端允许插入和删除，另一端只允许删除

栈和队列的常见考题：

1、栈和队列的实现，包括数组和链表的两种形式
2、两个栈实现一个队列，两个队列实现一个栈
3、要求实现一个栈，Push,pop,min的时间复杂度为O(1)
4、括号的匹配
5、前缀、中缀、后缀的表达式求值

**树**

树是一种抽象的结构，数是一个集合，每个节点通过边来连接，每个节点可能是一个空集，但是，更多的树是像大量的相互关联

树的特点：
每个节点有零个或多个子节点
没有父节点的节点称为根节点
每一个非根节点有且只有一个父节点
除了根节点以外，每个子节点可以分为多个不相交的子树

树和图最重要的特征是，树不存在环路

树的相关术语：

节点的度：一个节点含有的子节点的个数称为该节点的度
树的度：一颗树中最大的节点的度数，就是节点的度

叶节点：也叫分支节点，也就是度为零的节点
根节点：
树的层次：从根开始定义，根为第一层，根节点的子节点为第二层，以此类推
深度：节点到根节点的长度，根节点的深度为0
高度：节点到叶子节点的长度，同一层的高度不一定一样

森林：由m棵互不相交的树构成的集合称为森林
树有两类：

无序树：树中任意节点的子节点之间没有顺序关系，这种树称为无序树，也称为自由树
有序树：树中任意节点的子节点之间有顺序关系，这种树称为有序树

**二叉树**

二叉树，一个节点最多只有两个子节点，这种树称为二叉树，二叉树是有序树
斜树：所有节点都只有左子树的二叉树叫左斜树，所有节点都只有右子节点的树叫做右斜树，这二者统称为斜树

满二叉树：除了叶节点外每一个结点都有左右子叶且叶子节点都处在最底层的二叉树

完全二叉树：若设二叉树的高度为h,除了第h层外，其他各层(1~h-1)的结点树都达到最大个数，第h层有叶子结点，并且叶子结点都是从左到右依次排布，这就是完全二叉树

非空二叉树的性质：

1、在非空二叉树的第i层中至多有2^i-1个节点
2、深度为k的二叉树至多有2^(k+1)-1个节点
3、对于任何非空二叉树T，如果其叶子节点的个数为n0,度数为2的节点个数为n2，那么n0=n2+1


针对完全二叉树：
具有n个节点的完全二叉树的深度为log2n

对于完全二叉树，若从上到下，从左至右编号，则编号为i的节点，其左孩子节点编号必为2i，其右孩子节点编号必为2i+1，其双亲的编号必为i/2(i=1)时除外

二叉树的链式存储结构：
一个节点包含了当前节点的元素信息，同时还包含了指向两个孩子节点的指针

