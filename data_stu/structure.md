## 数据结构

### 1、如何衡量程序运行的效率

编写代码的核心就是完成计算

**复杂度是什么？**

代码执行过程中会消耗计算时间和计算空间
需要衡量的就是时间复杂度和空间复杂度

**这段代码对于资源的消耗是多少**

不管是时间还是空间，它们的消耗程度都与输入的数据量高度相关
为了更客观地衡量消耗程度，通常会关注时间和空间消耗量与输入数据量之间的关系

**如何计算复杂度**

复杂度是一个关于输入数据量N的函数
假设你的代码的复杂度是f(n)--->O(f(n))

- O(n)表示复杂度与计算实例的个数n线性相关
- O(logN)表示复杂度与计算实例的个数N对数相关

复杂度的计算方法遵循以下几个原则

- 复杂度与具体的常数系数无关
例如O(n)和O(2n)表示的是同样的复杂度
o(2n)=O(n+n)=O(n)+O(n)
一段o(2n)复杂度的代码只是先后执行两遍o(n)，其复杂度是一致的

- 多项式级的复杂度项加的时候，选择高者作为结果
例如O(n^2)+O(n)和o(n^2)表示的是同样的复杂度
o(n^2)+O(n)=O(n^2+n)

只需要通过更大变化率的二阶多项式来表征复杂度就可以

- O(1)表示一个特殊的复杂度

含义为某个任务通过有限可数资源即可完成
此处有限可数的具体意义是，与输入数量n无关
例如，代码处理10条数据需要消耗5个单位的时间资源，3个单位的空间资源
处理1000条数据，消耗的资源还是这么多

一些经验：
- 一个顺序结构的代码，时间复杂度是O(1)
- 二分查找，或者更通用地说是采用分而治之的二分策略，时间复杂度都是O(logn)
- 一个简单的for循环，时间复杂度是O(n)
- 两个顺序执行的for循环，时间复杂度是O(n)+O(n)=O(2n),也就是O(n)
- 两个嵌套的for循环，时间复杂度是O(n^2)

### 将时间复杂度和空间复杂度优化

程序优化的核心思路：
- 第一步，暴力解法
在没有任何时间，空间约束下，完成代码任务的开发

- 第二步，无效操作处理
将代码中无效计算，无效存储剔除，降低时间或空间复杂度
(学会并掌握递归、二分法、排序算法、动态规划等常用的算法思维)

- 第三步，时空转换
设计合理数据结构，完成时间复杂度向空间复杂度的转移
(对数据的操作进行细分，全面掌握常见的数据结构的基础知识)


### 数据处理的基本操作

想要先弄清楚数据在代码中被处理、加工的最小单位动作


### 数组和链表

数组，是一段地址连续的内存空间，他的坏处在于，由于地址连续，每一次新增内容，如果当前数组的连续的地址没有多余的了，数组需要重新找一段地址连续的空间

另外，数组在删除数据后，需要将剩余的数据进行迁移以保证地址的连续

链表的地址不是连续的，当某个地址存储一个元素之后，它会指向下一个位置
链表有效解决了数组的麻烦，但是带了一个新的问题，链表的查找比较麻烦

时间复杂度：
操作            链表            数组

查找            O(n)           O(1)
在头部插入/删除  o(1)           O(n)
在尾部插入/删除  O(n)           O(n)
在中间插入/删除  O(n)           O(n)

链表的插入，只需要将指针指向下一个节点，但是数组需要将其余的数据都移动一下，挪个位置出来才能插入
在尾部插入，链表需要找到尾部的位置，而数组直接在尾部放就可以了
在中间插入/删除，链表和数组的时间复杂度都是O(n)，但是链表的时间用在遍历上，但是数组的时间用在挪动位置上

链表的插入/删除时间复杂度

- 当我们要插入/删除指针当前指向的节点时，时间复杂度是O(1)
- 当我们要插入/删除某个给定值的节点的时候，我们需要遍历链表，所以是O(n)。

- 链表插入/删除时间复杂度O(n)是因为需要进行遍历引起的
- 数组插入/删除时间复杂度是O(n)则是因为数据的拷贝是覆盖导致的

遍历数组和遍历链表的效率区别

在访问数组的时候，因为局部性原理，数组会把之后的连续内存都读取过来，所以之后访问的数据都在一级缓存中了，而链表的查询不会进入缓存，查询的效率就慢一些

一般来说，插入删除很少，查询非常多，又不会out of memory，采用数组，如果怕是频繁的插入，遍历，查询检索很少，就可以采用链表


### 顺序表

线性表：顺序表，链表，栈，队列

顺序表：数组、引用数组，动态数组

在程序中，我们经常要将一组元素作为一个整体来管理使用
对于这种需求，最简单的办法就是将它们看成一个序列，一旦一个数据被添加，它相对于前后元素就一直保持不变，对于这种结构，就被称之为线性表

线性表有两端，可以被称为左右，或者顶部底部，
于线性表对应的就是非线性表，比如树，图

顺序表：在计算机内存当中，用一组地址连续的存储单元，依次存储数据的线性数据结构，这里要求地址连续

数组：在连续的地址空间中，存储类型相同的数据
数组的元素位置，称之为索引
利用元素的索引可以计算出该元素对应的存储地址
索引从0开始，索引看作是起始位置的偏移量
索引为0，意味着相对于数组的第一个位置偏移量为零的位置

索引从零开始，处理器可以直接进行指针偏移计算，效率很高
例如数组索引为0，那么指针就是p+0，

数组支持随机访问

引用数组：数组中存储的是引用，就是具体的数据的地址
可以解决数据类型必须一致的问题

动态数组：由于数组的地址空间是连续的，在使用的时候，我们需要先指定他的大小
那么有没有可以动态扩容的数组呢？答案是有的
list(Python) ArrayList(java)

分配数组的时候，会预留一部分空间，扩容的时候是1.25倍扩容

数组访问越界：在go语言越界会报panic

### 链表

链表中最简单的：单项链表

它包含两个值，当前节点的元素以及指向下一个节点的指针，而最后一个指向空值

链表的第一个节点，头节点，最后一个节点，尾节点

从头节点开始，通过每个节点的引用可以移动到下一个节点，当next为空的时候，我们确定该节点为尾节点

链表的实例：至少包含一个指向头节点的引用，如果没有头部的引用的话，就没有办法定位到任何的节点

我们还可以显示的保存一个指向尾节点的引用，这样可以避免为访问尾节点而遍历整个链表

还可以保存整个链表的长度，这样可以避免为计算链表的数量而遍历整个链表

**链表的插入**

向链表头部创建节点的时候，我们首先创建一个新的节点，让这个节点上的指针指向我们当前链表的头节点，然后让链表的头指针指向新的这个节点，这样就完成了一次链表的头部插入工作

尾部同理，将它的next指针设置为空，并设置当前尾节点的指针指向这个新的节点
并将链表的尾指针指向这个节点

**链表的删除**

从链表的头部删除节点：将链表当前头节点的指针置为空，并将链表的头指针指向它的下一个节点位置

从尾部删除节点的时候，需要遍历整个链表
因为任意一个节点只有指向上一个节点的指针，没有指向下一个节点的指针

为了克服这个问题，出现了双向链表
每一个链表既有前驱，又有后继，这样我们可以从任意节点访问到它的前一个节点和后一个节点

