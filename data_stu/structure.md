## 数据结构

### 1、如何衡量程序运行的效率

编写代码的核心就是完成计算

**复杂度是什么？**

代码执行过程中会消耗计算时间和计算空间
需要衡量的就是时间复杂度和空间复杂度

**这段代码对于资源的消耗是多少**

不管是时间还是空间，它们的消耗程度都与输入的数据量高度相关
为了更客观地衡量消耗程度，通常会关注时间和空间消耗量与输入数据量之间的关系

**如何计算复杂度**

复杂度是一个关于输入数据量N的函数
假设你的代码的复杂度是f(n)--->O(f(n))

- O(n)表示复杂度与计算实例的个数n线性相关
- O(logN)表示复杂度与计算实例的个数N对数相关

复杂度的计算方法遵循以下几个原则

- 复杂度与具体的常数系数无关
例如O(n)和O(2n)表示的是同样的复杂度
o(2n)=O(n+n)=O(n)+O(n)
一段o(2n)复杂度的代码只是先后执行两遍o(n)，其复杂度是一致的

- 多项式级的复杂度项加的时候，选择高者作为结果
例如O(n^2)+O(n)和o(n^2)表示的是同样的复杂度
o(n^2)+O(n)=O(n^2+n)

只需要通过更大变化率的二阶多项式来表征复杂度就可以

- O(1)表示一个特殊的复杂度

含义为某个任务通过有限可数资源即可完成
此处有限可数的具体意义是，与输入数量n无关
例如，代码处理10条数据需要消耗5个单位的时间资源，3个单位的空间资源
处理1000条数据，消耗的资源还是这么多

一些经验：
- 一个顺序结构的代码，时间复杂度是O(1)
- 二分查找，或者更通用地说是采用分而治之的二分策略，时间复杂度都是O(logn)
- 一个简单的for循环，时间复杂度是O(n)
- 两个顺序执行的for循环，时间复杂度是O(n)+O(n)=O(2n),也就是O(n)
- 两个嵌套的for循环，时间复杂度是O(n^2)

### 将时间复杂度和空间复杂度优化

程序优化的核心思路：
- 第一步，暴力解法
在没有任何时间，空间约束下，完成代码任务的开发

- 第二步，无效操作处理
将代码中无效计算，无效存储剔除，降低时间或空间复杂度
(学会并掌握递归、二分法、排序算法、动态规划等常用的算法思维)

- 第三步，时空转换
设计合理数据结构，完成时间复杂度向空间复杂度的转移
(对数据的操作进行细分，全面掌握常见的数据结构的基础知识)


### 数据处理的基本操作

想要先弄清楚数据在代码中被处理、加工的最小单位动作


### 数组和链表

数组，是一段地址连续的内存空间，他的坏处在于，由于地址连续，每一次新增内容，如果当前数组的连续的地址没有多余的了，数组需要重新找一段地址连续的空间

另外，数组在删除数据后，需要将剩余的数据进行迁移以保证地址的连续

链表的地址不是连续的，当某个地址存储一个元素之后，它会指向下一个位置
链表有效解决了数组的麻烦，但是带了一个新的问题，链表的查找比较麻烦

时间复杂度：
操作            链表            数组

查找            O(n)           O(1)
在头部插入/删除  o(1)           O(n)
在尾部插入/删除  O(n)           O(n)
在中间插入/删除  O(n)           O(n)

链表的插入，只需要将指针指向下一个节点，但是数组需要将其余的数据都移动一下，挪个位置出来才能插入
在尾部插入，链表需要找到尾部的位置，而数组直接在尾部放就可以了
在中间插入/删除，链表和数组的时间复杂度都是O(n)，但是链表的时间用在遍历上，但是数组的时间用在挪动位置上

链表的插入/删除时间复杂度

- 当我们要插入/删除指针当前指向的节点时，时间复杂度是O(1)
- 当我们要插入/删除某个给定值的节点的时候，我们需要遍历链表，所以是O(n)。

- 链表插入/删除时间复杂度O(n)是因为需要进行遍历引起的
- 数组插入/删除时间复杂度是O(n)则是因为数据的拷贝是覆盖导致的

遍历数组和遍历链表的效率区别

在访问数组的时候，因为局部性原理，数组会把之后的连续内存都读取过来，所以之后访问的数据都在一级缓存中了，而链表的查询不会进入缓存，查询的效率就慢一些

一般来说，插入删除很少，查询非常多，又不会out of memory，采用数组，如果怕是频繁的插入，遍历，查询检索很少，就可以采用链表