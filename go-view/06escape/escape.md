### go的逃逸分析

要搞清楚go的逃逸分析，一定要搞清楚内存分配和堆栈

内存即可以分配到堆中，也可以分配到栈中

> go语言是如何进行内存分配的?其设计初衷和实现原理是什么?

#### 1、内存管理

内存管理主要包括两个动作:分配与释放。逃逸分析就是服务于内存分配的，而内存的释放由GC负责

**栈**

在go语言中，栈的内存是由编译器自动进行分配和释放的，栈区往往存储着函数参数、局部变量和调用函数帧，他们随着函数的创建而分配，随着函数的
退出而销毁

GO应用程序运行时，每个goroutine都维护着一个自己的栈区，这个栈区只能自己使用不能被背的goroutine使用。
栈是调用栈的简称。一个栈通常包含了许多栈帧，它描述的是函数之间的调用关系

**堆**

与栈不同的是，堆区的内存一般是由编译器和工程师自己共同管理分配，交给GC来释放。
在堆上分配时，必须找到一块足够大的内存来存放新的变量数据。后续释放时，垃圾回收器扫描堆空间寻找不再被使用的对象

我们可以简答的理解为：我们用GO语言开发过程中，要考虑的内存管理只是针对堆内存而言的

程序在运行期间可以主动从堆上申请内存，这些内存通过GO的内存分配器分配，并且由垃圾收集器回收

**栈和堆的对比**

加锁

- 栈不需要加锁：每个goroutine都独享自己的栈空间，这就意味这栈上的内存操作是不需要加锁的

- 堆有时需要加锁：堆上的内存，有时需要加锁防止多线程冲突

> 为什么堆上的内存有时需要加锁？而不是一直需要加锁

因为GO的内存分配策略学习了TCMalloc的线程缓存思想，它为每个处理器分配了一个mcache，注意：从mcache分配内存也是无锁的

性能
- 栈内存管理 性能号：栈上的内存，他的分配和释放非常高效。简单的说，它只需要两个CPU指令，一个是分配入栈，另外一个是栈内释放。只需要借助栈相关寄存器即可完成

- 对于程序堆上的内存回收，还需要有标记清楚阶段，例如Go采用的三色标记法

缓存策略

- 栈缓存性能更好
- 堆缓存性能较差

原因是：栈内存能更好地利用CPU的缓存策略，因为栈空间相较于堆来说更连续


### 逃逸分析

相比于把内存分配到堆中，分配到栈中优势更明显

GO语言也是这么做的：GO编译器会尽可能的将变量分配到栈上

但是，在函数返回后无法证明变量未被引用，则变量将被分配到堆上，该变量不随函数栈的回收而回收，以此避免悬挂指针的问题

另外，如果局部变量占用内存非常大，也将其分配在堆上

> Go是如何确定内存分配是栈上还是堆上的呢？

答案是逃逸分析

编译器通过逃逸分析技术去选择堆或者栈，逃逸分析的基本思想如下：检查变量的生命周期是否完全可知的，如果通过检查，则在栈上分配，否则，就是所谓的逃逸，必须在堆上进行分配

**逃逸分析的原则**

go语言虽然没有明确的说明逃逸分析原则，但是有以下几点准则，是可以参考的

- 不同于JAVA JVM的运行时逃逸分析，GO的逃逸分析是在编译期完成的，编译期无法确定的参数类型必定放到堆中

- 如果变量在函数外部存在引用，则必定放在堆中
- 如果变量占用内存较大，则优先放到堆中
- 如果变量在函数外部没有引用，则优先放到栈中

**逃逸分析举例**

我们使用这个命令来查看分析的结果：go build -gcflags '-m -m -l'


#### 逃逸分析实践

1、参数是interface类型

```go

package main

import "fmt"

func main(){
    a:=666
    fmt.Println(a)
}

```

这里a会逃逸到堆中，因为fmt.Println()这个函数的参数是interface{}类型，编译期无法确定其具体的参数类型，所以内存分配在堆中

2、变量在函数外部有引用

```go
package main

func test()*int{
    a:=10
    return &a
}

func main(){
    _=test()
}
```

变量啊在函数外部存在引用
当函数执行完毕，对应的栈帧就被销毁，但是引用已经被返回到函数之外，如果这时外部通过引用地址取值，虽然地址还在，但是这块内存已经被释放回收了，这就是非法内存

为了避免非法内存，在这种情况下变量的内存分配必须分配到堆上

3、变量内存占用较大

```go
package main

func test(){

    a:=make([]int,10000,10000)
    for i:=0;i<10000;i++{
        a[i]=1
    }
}

func main(){
  test()
}
```

这里发生了逃逸，当变量占用内存较大时，会发生逃逸分析，将内存分配到堆上

4、变量大小不确定时

```go
package main

func test(){
    l:=1
    a:=make([]int,l,l)
    for i:=0;i<l;i++{
        a[i]=i
    }
}

func main(){
 test()   
}
```

这里就会发生逃逸
虽然在代码段中给变量l赋值了1，但是编译期间只能识别到初始化int类型切片时，传入的长度和容量是变量i，编译期并不能确定变量l的值，所以发生了逃逸，会把内存分配到堆中

