## go 的垃圾回收机制

go v1.3之前的标记清除(mark and sweep)
go v1.5的三色标记法
go v1.8的混合写屏障

### 1.3、标记清除(v1.3)

(1)、找到程序与对象的可达关系，目前程序的可达对象1-2-3,4-7这5个对象
找到之后STW暂停一切业务
(2)、标记可达对象
(3)、标记完之后，没有标记的对象，就被定义为垃圾，然后回收，回收完之后STW结束
(4)、停止暂停，让程序继续跑，重复上述过程，知道程序生命周期结束

标记清除方法的缺点：

STW,stop the world:让程序暂停，程序出现卡顿
标记需要扫描整个heap(扫描全部的堆栈)
清除数据会产生heap碎片(对象的地址不是连续的)

怎么避免这些缺点:

原来的STW范围包含启动STW--->Mark标记--->停止STW---Sweep清除

go的改进在于将Sweep清除和停止STW调换一下位置，清除和业务并行执行，这种方式还是很慢

后来引入了三色标记法


### 三色标记法

还是之前的程序，有对象1,2,3,4,5,6,7

在整个gc里面会记录三个表:
第一个表:白色标记表
第二个表:灰色标记表
第三个表:黑色标记表

程序起初创建，全部标记为白色，将所有对象放入白色集合中

首先遍历程序的Root Set(非递归形式，只遍历一次)，将可达对象标记为灰色。得到灰色节点
将第一层节点标记为灰色，同时，将这些节点从白色标记表移动到灰色标记表

接下来遍历灰色节点，将可达对象标记为灰色，将可达对象从白色表移动到灰色表
同时将遍历完毕的对象，从灰色变为黑色，将这些节点从灰色表移动到黑色表

重复上一步，直到灰色标记表中无任何对象，剩下的只有黑色和白色
收集白色的对象，白色的对象就是要收集的垃圾

三色标记法的流程：
1、只要是创建的对象，都默认为白色
2、gc开始之后，从根节点开始遍历所有对象，把遍历到的对象从白色集合放入"灰色"集合
3、遍历灰色的集合，将灰色对象引用的对象从白色集合放入灰色集合，之后将此灰色对象放入黑色集合
4、重复第三步，直到灰色表中没有任何值，整个结构中只有黑色和白色节点
5、将白色对象进行回收

和标记清除的区别在于，动态的，逐层的遍历，而不是标记清除那种一次遍历

### 如果三色标记中不启动STW

三色标记最不希望发送的事：
1、一个白色对象被一个黑色对象引用（白色被挂在黑色下）
2、灰色对象与它之间的可达关系的白色对象遭到破坏（灰色对象同时丢失了该白色）
这两个条件同时满足时，就会出现对象丢失的问题

为了满足不发生这种事情，最简单的方式就是STW
STW过程有明显的资源浪费，对所有的用户程序都有很大影响
如何能保证对象不丢失的情况下尽可能地提高GC效率，减少STW时间呢？


### 强弱三色不变式

之前地三色标记如果发送两个条件就会丢失对象
那么，我们可以通过破坏两个条件同时成立来阻止这种情况

**强三色不变式**

强制性地不允许黑色对象引用白色对象。
如果黑色对象引用灰色对象，允许。
这样可以破坏条件1，也就是一个黑色对象引用了一个白色对象

**若三色不变式**

黑色可以引用白色对象，白色对象存在其他灰色对象对它的引用，或者可达它的链路上游存在灰色对象

假如一个黑色对象引用白色对象，同时这个白色对象被白色对象引用，这种条件就是不允许的，假如一个黑色对象引用一个白色对象，这个白色对象被一个灰色对象引用
，这种情况是运行的，或者白色对象被一个白色对象引用，但是它的上游有灰色对象

这种情况破坏了条件2：也就是灰色对象与它之间的可达关系遭到破坏
在三色标记中如果满足强/弱之一，即可保证对象不丢失

### 屏障机制

屏障：在程序执行的某个流程中，额外的加一层额外的判断机制
屏障机制最终有两种机制：
1、插入屏障：当一个对象被引用的时候，触发
2、删除屏障：一个对象被删除的时候，触发

**插入屏障**

具体操作：在A对象引用B对象的时候，B对象被标记为灰色。(将B挂在A下游，B必须被标记为灰色)
满足：强三色不变式(不存在黑色对象引用白色对象的情况了，因为白色对象会强制变成灰色)


