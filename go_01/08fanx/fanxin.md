## go语言泛型

1.什么是泛型

泛型允许程序员在强类型程序设计语言中编写代码时使用一些以后才指定的类型，在实例化时作为参数指明这些类型。ーー换句话说，在编写某些代码或数据结构时先不提供值的类型，而是之后再提供。

泛型是一种独立于所使用的特定类型的编写代码的方法。使用泛型可以编写出适用于一组类型中的任何一种的函数和类型。

泛型语法为go语言添加了三个新的重要特性:

1.函数和类型的类型参数
2.将接口类型定义为类型集，包括没有方法的类型
3.类型推断，它允许在调用函数时在许多情况下省略类型参数

> 类型参数

类型形参和类型实参

之前的函数学习中，我们了解到实际参数和形式参数
泛型带来类型形参和类型实参

```go
func min[T int|float64](a,b T)T{
    if a<=b{
        return a
    }
    return b
}
// 这里面[T int|float64]，这里的T就是类型形参,int|float64时类型约束

min[int](10,20)  // [int]就是类型实参
```

> 类型实例化

我们定义的min函数同时支持int和float64两种类型，也就是说当调用min函数时，我们既可以传入int类型的参数，也可以传入float64类型参数

向min函数提供类型参数就称为实例化

类型实例化分为两步进行：
    1、首先，编译器在整个泛型函数或类型中将所有类型形参替换为它们各自类型实参
    2、其次，编译器验证每个类型参数是否满足相应的约束
在成功实例化之后，我们将得到一个非泛型函数，它可以像任何其他函数一样被调用

> 类型参数的使用

除了函数中支持使用类型参数列表外，类型也可以使用类型参数列表

```go
type myslice[T int|string] []T

type mymap[K int|string,V float32|float64]map[K]V

type Tree[T interface{}] struct{
    left,right *Tree[T]
    value T
}
```

泛型类型可以有方法，例如上面的Tree实现一个查找元素的Lookup方法

```go
func (t *Tree[T])Lookup(x T)*Tree[T]{...}
```
要使用泛型类型，必须先进行实例化
```go
var stringTree Tree[string]
```

