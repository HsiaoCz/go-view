## go 常用的数据结构和算法

**时间复杂度、空间复杂度**

冒泡排序、选择排序、插入排序的时间复杂度都是 O(n^2)

### 1、常用算法

1、冒泡排序

它的平均时间复杂度是 O(n^2),最好的情况是 O(n^2)，最差的情况是 O(n^2),空间复杂度 O(1)
最好的情况是已经排好序的

这个算法很稳定，什么叫算法的稳定:
假设有 a b 且 a=b
假如 a 在 b 的前面，无论怎么排，排序完成后，a 依然在 b 的前面
如果满足这种情况，就说明这种算法很稳定

假如有一组数据

1 4 3 24 17 12 15

第一遍排序：1 和 4 比较，1<4 所以位置不变，4 和 3 比较,4 更大，所以调换位置，4 和 24 比较，位置不变
24 和 17 比较，交换位置，24 和 12 比较，交换位置，24 和 15 比较，交换位置
1 3 4 17 12 15 24
每比较一次，都会寻找一个最大的数，第一次比较会确定最好一个位置的数
第二次比较会确定倒数第二个位置的数

```go
func BubbleSort(a []int, n int) {
    // 如果传进来的数组长度<=1直接返回
	if n <= 1 {
		return
	}
    // 否则开始排序
	for i := 0; i <= n; i++ {
		// 提前退出的标志
		flag := false
		for j := 0; j < n-i-1; j++ {
			if a[j] > a[j+1] {
				a[j], a[j+1] = a[j+1], a[j]
				// 此次冒泡有数据交换
				flag = true
			}
		}
		// 如果没有数据交换，提前退出
		if !flag {
			break
		}
	}
}
```

2、选择排序

时间复杂度 O(n^2) 最好情况 O(n^2),最差的情况 O(n^2)，空间复杂度 O(1)

假设有这么一个数组

4 1 3 24 19 16 17

我们把这个数组分为有序区和无序区，在初始状态下，有序区的个数为 0
无序区，n 个数
它的算法过程是这样的，我们遍历无序区，比如说按照从小到大排序
那么我们每次找出最小的数，讲最小的数放到有序区

第一趟，最小的数是 1，那么有序区，放个 1
第二趟，最小的数是 3，那么有序区，放 1，3
经过 n-1 趟，数组就变成有序的了

```go
// 选择排序
func SelectionSort(a []int, n int) {
    // 如果传递进来的数组长度<=1，直接返回
	if n <= 1 {
		return
	}
    // 否则开始遍历
	for i := 0; i < n; i++ {
		// 查找最小的值
        // 先声明一个值，代表最小值
		minIndex := i
		for j := i + 1; j < n; j++ {
			if a[j] < a[minIndex] {
				minIndex = j
			}
		}
		// 交换
		a[i], a[minIndex] = a[minIndex], a[i]
	}
}
```

3、插入排序

时间复杂度 O(n^2)，最坏时间复杂度 O(n^2)，最好时间复杂度 O(n),空间复杂度 o(1)

插入排序的思想：

假如有这么一个数组

4 1 3 24 19 16 17

插入排序的，首先选择第一个元素，4，它的前面没有值，直接放着不变
然后选择 1，让 1 和 4 比较，1 小于 4，所以放在前边
所以第一趟：4 1 3 24 19 16 17
第二趟：1 4 3 24 19 16 17
第三趟：1 3 4 24 19 16 17 ：第三趟选择 3，让他和前一位进行比较，如果比前一位小就插入
插入排序，每次选择一个和前面的依次比较进行插入

插入排序有点像打扑克牌

```go
// 插入排序
func InsertionSort(a []int, n int) {
    // 如果传入的数组长度小于等于1直接返回
	if n <= 1 {
		return
	}
    // 否则开始排序
    // 从索引为1，也就是第二个元素开始，和前面的进行比较
	for i := 1; i < n; i++ {
		value := a[i]
		j := i - 1
		// 查找要插入的位置并移动数据
		for ; j >= 0; j-- {
			if a[j] > value {
				a[j+1] = a[j]
			} else {
				break
			}
		}
		a[j+1] = value
	}
}
```
