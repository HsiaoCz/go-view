## rabbitMQ

### 1、AMQP协议

AMQP是一个提供统一消息服务的应用层标准协议，基于此协议得到客户端与消息中间件可传递消息，
并不受客户端/中间件不同产品，不同开发语言等条件的限制

AMQP协议是一种二进制协议，提供给客户端与消息中间件之间异步，安全，高效的交互

AMQP协议作为中间层服务，把消息生产者和消费服务分隔开来，当消息生产者出现异常，不影响消费者对消息的消费，当消费者出现异常时
生产者生产的消息可以存放到服务的内存或者磁盘，不会影响到消费的速率，同时，消息也可以基于路由的规则可以投递到指定的消费者消费

AMQP基于模块化，通过Exchange和MEssage Queue两个组合实现消息路由分发

AMQP的架构是这样的，左边的生产者将消息投递给交换机，交换机根据路由的不同将消息投递给队列
消费者从队列消费消息

AMQP的四个主体：生产者，交换机，队列，消费者

**生产者**
生产者生产消息的主体，消费者消费消息的主体

生产者生产一条消息，将消息丢到消息代理，消息代理将消息传递到消费者手上

**交换机**

交换机就像是消息代理的路由器，负责拿到一个消息之后，根据确定的规则（路由键）将它路由给一个或零个队列。交换机具备多种路由模式
基于消息生产者和路由规则可以将消息投递到指定的Message Queue，交换机收到消息生产者投递的消息，基于路由规则及队列绑定关系匹配到投递对应的交换机或者队列进行分发，交换机不存储消息，只做转发

交换机分为直连交换机：根据路由键完全匹配的投递到对应的队列。
扇形交换机：无视路由键，将消息进行拷贝，并路由到给绑定到它身上的所有队列，提供一个广播的效果
主题交换机：根据路由键按模式匹配的投递到对应的队列

**队列**

消息的暂存地，至少有一个消费者订阅了队列的话，消息会立即发送给这些订阅的消费者。但是如果消息到达了无人的订阅队列，消息会在队列中等待，等待有了消费者便进行分发

Exchange和Message Queue之间存在绑定关系，消息到了Exchange后基于路由策略可以将消息投递到已绑定且符合路由策略的Message Queue

消息队列会将消息存储到内存或者磁盘中，并将这些消息按照一定顺序转发给一个或者多个消费者，每个消息队列独立隔离的，相互不影响

消息队列具有不同的属性：私有，共享，持久化，临时，客户端定义或者服务端定义等，可以基于实际需求选择对应的类型

**消息**

消息是信息的载体，也是AMQP协议的一个实体，消息包括两部分
载荷：真正的信息，是你想要传输的任何内容，该部分内容对消息代理来说是透明的
元消息：包含；路由键，内容类型，编码，是否持久化等等消息属性，会被消息代理所解析，消息代理根据消息的属性对消息进行投递，存储等等。这个部分被消息代理所关心，而消费者对其是不关心的。

**信道**

网络信道，是建立在connection连接之上的一种轻量级的连接。几乎所有的操作都在Channel中进行，Channel是进行消息读写的通道，客户端可以建立对各channel，每个channel代表一个会话任务
如果把Connection比作一条光纤电缆的话，那么Channel信道就比作成光纤电缆中的其中一束光纤。一个Connection上可以创建任意数量的Channel

大部分业务操作都是在channel这个接口完成的
- 队列声明(queueDeclare)
- 交换机声明(exchangeDeclare)
- 队列绑定(queueBind)
- 发布消息(basicPulish)
- 消费消息(basicConsume)

### 工作模式

**1、简单模式**

简单模式：一个消费者消费，一个生产者生产

**2、工作模式**

一个生产者生产，多个消费者消费

**3、订阅模式**

生产者将消息发生到交换机，交换机将消息发送到和它绑定的队列
使用广播类型的

**4、路由模式**

生产者生产消息后，发送给交换机，交换机会根据路由键将消息发送到不同的消息队列中

**5、主题模式**

和路由模式有点像，是路由模式的升级版，精确匹配路由键，路由键加了通配符

### 消息的持久化

当rabbitMQ重启后，未消费的消息，可以在服务重启后继续消费，不会丢失

### 死信队列

DLX全称是Dead-Letter-Exchange，也可以称为死信交换机，就是当一个队列中的消息变成死信以后，会被重新发送到另一个交换机，这个交换机就是死信交换机，而绑定死信交换机的队列就是死信队列

什么情况下会出现死信队列：
- 消息被拒绝
- 消息过期
- 队列达到最大长度

使用死信队列，只需要定义队列的时候设置x-dead-letter-exchange指定交换机就可以了

### 延时队列

延时队列，延时队列就是当消息发送以后，并不想让消费者立刻拿到消息，而是等待特定时间后消费者才拿到消息，来消费

延时功能可以通过设置过期时间+死信队列来实现

延迟队列实现的流程

1、生产者生产消息，将消息发送到交换机
2、交换机通过需要延时三秒的路由键来把消息发送到延时三秒的队列，通过延迟八秒的路由键将消息发送到延迟八秒的消息队列中
3、延迟三秒的队列在时间过期后将消息发送到死信交换机，延迟八秒队列将消息发送到死信交换机
4、死信交换机将消息发送到延迟三秒死信队列，和延迟八秒死信队列
5、消费者从死信队列消费消息

如果没有死信交换机，在延迟队列时间到期后，消息会丢失，通过死信交换机，将消息发送到死信交换机可以避免消息的丢失

### docker安装rabbitMQ

```bash
# 拉取镜像
docker pull rabbitmq:3.7.7-management

# 启动镜像
docker run -d --name rabbitmq3.7.7 -p 5672:5672 -p 15672:15672 -v `pwd`/data:/var/lib/rabbitmq --hostname myRabbit -e RABBITMQ_DEFAULT_VHOST=my_vhost  -e RABBITMQ_DEFAULT_USER=admin -e RABBITMQ_DEFAULT_PASS=admin 2888deb59dfc
```

访问rabbitMQ

```
浏览器访问：http://172.29.194.124:15672
```

登录名和密码:admin admin

### go语言操作rabbitMQ

安装

```go
go get -u github.com/streadway/amqp
```