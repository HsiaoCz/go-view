# 设计模式和设计原则

## 设计原则

1、单一职责原则
2、开闭原则
3、里氏代换原则
里氏代换，使用实现类来替换抽象接口
4、依赖倒转原则
依赖于抽象而不是依赖于具体的类，针对接口编程
5、接口隔离原则
不强迫用户依赖它不需要的接口，一个接口只提供一种对外的功能，不把所所有的操作都封装到一个接口
6、合成复用原则
如果使用继承，会导致父类的任何变换都会影响子类的行为，
使用组合则可以避免这种情况，推荐使用组合而不是继承
7、迪米特法则
一个对象应该对其他对象尽可能少的了解，从而降低各个对象之间的耦合
提高系统的可维护性，例如在一个程序中，如果各个模块之间相互调用时，
通常会提供一个统一的接口来实现，这样其他模块就不需要了解另外一个模块的内部实现细节，
这样，当一个模块内部的实现发生改变时，不会影响其他的模块

## 设计模式

**简单工厂方法模式:**

具体分为工厂角色:简单工厂方法模式的核心，它负责创建所有实例的内部逻辑。
工厂类可以被外界直接调用，创建所需的产品对象

抽象产品角色：简单工厂模式所创建的所有对象的父类，它负责描述所有实例所共有的公共接口

具体产品角色：简单工厂模式所创建的具体的实例对象

简单工厂实现了对象的创建和使用的分离
不需要记住具体的类名，记住参数即可，减少使用者记忆量

缺点是：
对工厂的职责过重，一旦不能工作，系统就会受到影响
增加系统中类的个数，复杂度和理解度增加
违反了开闭原则，新增加产品需要修改工厂的逻辑，工厂越来越复杂

它适用于工厂类负责创建对象比较少，由于创建的对象少，不会造成工厂方法中的业务逻辑太过复杂
客户端只知道传入工厂类的参数，对于如何创建对象不关心

**工厂方法模式**

简单工厂方法模式不满足开闭原则，可以认为工厂方法模式给简单工厂方法模式加上了开闭原则
还是之前的水果举例子

之前的水果，有一个类作为工厂，它不满足开闭

当我们需要增加一种水果时，就需要修改它的方法

我们给它加上开闭，也就是有一个抽象的工厂，每一种水果的生产对应一个工厂
这样，添加新的水果就是，新建一个水果类，这样就满足工厂方法模式了

**抽象工厂方法模式**

抽象工厂方法模式，针对产品族和产品等级结构
针对产品族是符合开闭的，但是针对产品等级结构，是完全不符合开闭原则的

### 结构型模式
 
结构型模式的要点，让类和类进行组合，获得更大的结构

代理模式，适配器模式，装饰器模式，外观模式


**代理模式**

举个例子，如果我要给自己的游戏升级，但是我比较懒，我请一个代理来给游戏升级
并且还有额外的收益

**装饰器模式**

通过一个装饰器类将一个类变为一个新的类
比如将一个裸手机，通过一个装饰器类，装饰成一个贴膜的手机

**适配器模式**

比如iphone的充电器是5v的，但是家用电压一般是220V，适配器可以将220v的电压给适配成手机能用的5v的

适配器相当于一个中间角色，它将原本不能互相兼容的类能够一起工作

**外观模式**

举个例子，家里有很多电器，每个电器都有一个遥控器，
我们可以提供一个智能路由器，使用一个遥控器遥控智能路由器，通多它使用各自电器

### 行为型模式

行为型模式用来对类或对象怎样交互和分配职责进行描述

**模板方法模式**

比如说制作一杯咖啡，需要煮水，冲咖啡，导入杯中，加料

模板方法模式，用在流程相同，但是具体的内容不一样的事情上

比如泡茶和跑咖啡

**命令模式**

命令模式，有命令的收集者，命令的执行者
命令收集者收集命令，交给命令的执行者执行

**策略模式**

比如说，有一个人物类，有装备，可以战斗 有一个抽象的策略，可以挥出武器，比如匕首，AK47
